[
{
	"uri": "/1-server/1.1-commandline/",
	"title": "Các câu lệnh linux cơ bản",
	"tags": [],
	"description": "",
	"content": "\rVới từng command, bạn có thể nhập [command] --help để hiển thị thông tin cùng các [OPTION] command hỗ trợ hoặc [command] --version để check phiên bản command.\nLuôn chú ý đến đường dẫn khi chạy lệnh.\nCommand pwd Được dùng để tìm đường dẫn của folder hiện tại Trả về đường dẫn đầy đủ dẫn tới folder hiện tại Command whoami Dùng để lấy thông tin của người dùng đang đăng nhập trên server Command ls Liệt kê các file/folder trong thư mục hiện tại Syntax: ls -[OPTION] [FILE/FOLDER] Các [OPTION] hay sử dụng: -a: Liệt kê thêm các file/folder dạng .tên-file -R: Liệt kê đệ quy(tất cả các file/folder bên trong) -l: Thêm thông tin chi tiết của file/folder -s: Sắp xếp theo dung lượng từ lớn đến bé -r: Đảo ngược thứ tự khi sắp xếp Command cd Dùng để di chuyển giữa các thư mục Sử dụng tab để hệ thống gợi ý/tự động hoàn thiện tên folder muốn trỏ đến Syntax: cd [FOLDER/PATH] Trở về folder cấp cao hơn sử dụng cd .., áp dụng nhiều cấp Trở về folder ngay trước khi mình cd sử dụng cd - Trở về thư mục khi login ssh sử dụng cd hoặc cd ~ Command nano Là 1 trình soạn thảo văn bản đơn giản trên terminal (tương tự notepad) Syntax: nano -[OPTION] [FILE] Các [OPTION] hay sử dụng: -w: Mở file định dạng chuẩn -l: Hiển thị số dòng -nX hoặc +X: Mở file tại dòng số X -B: Backup file Các thao tác hay sử dụng khi vào trình soạn thảo: Tìm kiếm text: Ctrl W Thay thế text: Ctrl \\ Xoá dòng hiện tại: Ctrk K Đi tới dòng: Ctrl _ Lưu file: Ctrl S Thoát: Ctrl X Trường hợp file đã chỉnh sửa mà muốn lưu: Y + enter Trường hợp file đã chỉnh sửa mà không muốn lưu: N Command mkdir Tạo folder mới Syntax: mkdir -[OPTION] [DIRECTORY] Các [OPTION] hay sử dụng: -p: Tạo folder cha nếu chưa tồn tại Command touch Tạo file mới Syntax: touch -[OPTION] [FILENAME] Command cat Dùng để in nội dung file Syntax: cat -[OPTION] [FILENAME] Command tail In ra console 10 dòng (mặc định) cuối của file Syntax: tail -[OPTION] [FILENAME] Các [OPTION] hay sử dụng: -nX: In ra X dòng cuối. Command head In ra console 10 dòng (mặc định) đầu của file Syntax: head -[OPTION] [FILENAME] Các [OPTION] hay sử dụng: -nX: In ra X dòng. Command clear Xoá nội dung trong màn console (dọn dẹp) Command rm Xoá file/folder. Syntax: rm -[OPTION] [FILENAME] Các [OPTION] hay sử dụng: -f: Không hỏi lại, xoá cả trong trường hợp file/folder không tồn tại -r: Xoá tất cả files/folders nằm bên trong (đệ quy) -d: Xoá các các folders rỗng Command grep Tìm kiếm mẫu text Syntax: grep -[OPTIONS] PATTERN [FILE...] Các [OPTION] hay sử dụng: -R hoặc -r: Tìm kiếm đệ quy (các file/folder con) -l: Chỉ hiển thị tên file -n: Hiển thị số dòng khớp mẫu -c: Đếm số mẫu khớp -i: Không phân biệt hoa thường Command find Được sử dụng để tìm kiếm files và folders trong hệ thống tập tin dựa trên các tiêu chí khác nhau Syntax: find [PATH] [OPTIONS] Các [OPTIONS] hay sử dụng: Tìm theo tên: -name \u0026ldquo;[PATTERN]\u0026rdquo; (phân biệt hoa thường) \u0026gt;\u0026lt; -iname \u0026ldquo;[PATTERN]\u0026rdquo; (không phân biệt hoa thường) Tìm theo loại: Folder: -type d File: -type f Tìm theo kích thước (c: byte, k: KB, M: MB, G: GB) Lớn hơn 10MB: -size +10M Nhỏ hơn 10MB: -size -10M Tìm theo ngày chỉnh sửa: Trong 7 ngày gần nhất: -mtime -7 Trước đó 7 ngày so với hiện tại: -mtime +7 Thực thi một lệnh trên mỗi tệp khớp: -exec [COMMAND] {} \\; Tìm với quyền cụ thể: -perm [PERMISSION] Tìm với user cụ thể: -user [USER] Tìm với group cụ thể: -group [GROUP] Giới hạn mức độ đệ quy: -maxdepth [NUMBER] Ví dụ sử dụng lệnh phân quyền file/folder trong magento: find app/code lib var generated vendor pub/static pub/media app/etc \\( -type d -or -type f \\) -exec chmod g+w {} \\; Command chown Được sử dụng để thay đổi quyền sở hữu (owner/group) của file và folder Syntax: chown [OPTIONS] [USER]:[GROUP] [FILE/FOLDER] Các [OPTIONS] hay sử dụng: -R: Phân quyền đệ quy (cả các file/folder con) Có thể điền 1 trong 2 [USER] và [GROUP] nhưng vẫn cần phải giữ lại dấu :\nĐể biết thêm về phân quyền, truy cập link sau\nCommand chmod Được sử dụng để thay đổi quyền truy cập (permissions) của file và folder Syntax: chmod [OPTIONS] [MODE] [FILE/FOLDER] Các [OPTIONS] hay sử dụng: -R: Phân quyền đệ quy (cả các file/folder con) Để biết thêm về phân quyền, truy cập link sau\nCommand groups In ra các groups mà [USER] thuộc, nếu không điền [USER] thì sẽ in ra của chính user hiện tại Syntax: groups [USER] Command useradd Được sử dụng để tạo tài khoản người dùng mới trên hệ thống Syntax: useradd [OPTION] [USERNAME] Các [OPTION] hay sử dụng: -s [SHELL] (thường là /bin/bash): Chỉ định shell đăng nhập của người dùng -p $(openssl passwd -1 [PASSWORD]): Chỉ định mật khẩu cho người dùng -G [GROUP1,GROUP2,...]: Thêm người dùng vào các groups -u [UID]: Tạo người dùng mới với UID cụ thể -d [HOME_DIR]: Chỉ định thư mục chính (home directory) -m: Tạo thư mục chính nếu chưa tồn tại Command usermod Được sử dụng để thay đổi thông tin chi tiết của tài khoản người dùng hiện có trên hệ thống Syntax: usermod [OPTION] [USER] Các [OPTION] hay sử dụng (tương tự như useradd và bổ xung thêm vài option sau): -aG [GROUP]: Thêm groups (không có optino a thì các groups hiện có sẽ bị xoá) -l [NEW_USER] [OLD_USER]: Đổi tên người dùng -L: Vô hiệu hóa mật khẩu -U: Kích hoạt lại mật khẩu Command su Dùng để switch user trong phiên ssh Syntax: su [OPTION] [-] [USSER [ARGUMENT...]] Thường không sử dụng tới [ARGUMENT] Thêm option [-] để truy cập vào home directory của [USER] Có thể truy cập root bằng command: sudo -i Command ping Được sử dụng để kiểm tra kết nối mạng giữa server và một địa chỉ IP hoặc tên miền cụ thể Syntax: ping [OPTIONS] [DESTINATION] Các [OPTION] hay sử dụng: -c [COUNT]: Số lượng gói tin sẽ được gửi: -i [INTERVAL]: Khoảng thời gian (second) giữa các gói tin -s [PACKET_SIZE]: Kích thước của mỗi gói tin gửi đi (mặc định là 56 bytes) -W: Thiết lập thời gian chờ (second) cho mỗi phản hồi -q: Chỉ hiển thị kết quả tóm tắt khi hoàn thành -n: Chuyển sang dạng IP thay vì tên miền Command telnet Được sử dụng để tạo một kết nối Telnet tới một máy tính từ xa tương tự như ssh (thường được sử dụng để kiểm tra port có mở hay không vì bảo mật khá kém) Syntax: telnet [OPTIONS] [HOST] [PORT] Ví dụ: telnet localhost 22 Command netstat Được sử dụng để hiển thị thông tin chi tiết về các kết nối mạng, bảng định tuyến, thống kê giao thức và các socket (cả TCP và UDP) đang hoạt động trên hệ thống Thường được dùng để kiểm tra kết nốt các cổng trên server Syntax: netstat [OPTIONS] Các [OPTION] hay sử dụng: -a: Hiển thị tất cả các kết nối mạng và socket -t: Hiển thị các kết nối TCP -u: Hiển thị các kết nối UDP -l: Hiển thị các socket đang lắng nghe -n: Hiển thị địa chỉ và số port dưới dạng số -p: Hiển thị thông tin về chương trình sử dụng socket Sử dụng user root hoặc sudo để có quyền xem tất cả thông tin: netstat -tulpn\nCommand du Trả về mức sử dụng ổ đĩa (disk) của các files/folders cụ thể Syntax: du [OPTION] [FILE/FOLDER] Các [OPTION] hay sử dụng: -c: Thêm 1 dòng tổng dung lượng vào cuối -h: In thông số dạng kb, mb, gb (human-readable) -s: In tổng quát của file/foler gốc --exclude-from=[FILE] hoặc --exclude=[PATH]: In tất cả ngoại trừ folder Có thể kết hợp command sort để sắp xếp: du -csh * | sort -rh. Sử dụng command này kèm command zip/rm để lưu trữ/loại bỏ những file/folder quá lớn/dư thừa.\nCommand df Trả về thông tin ổ cứng mà file/folder thuộc về (mặc định trả về full các ổ) Syntax: df [OPTION] [FILE] Thưởng chỉ sử dụng option -h để hiện thị dữ liệu dạng human-readable Ví dụ: df -h Command which Trả về đường dẫn tới command khi được execute Syntax: which [COMMAND] Command curl Truyền dữ liệu từ hoặc đến một máy chủ, sử dụng nhiều giao thức khác nhau (mình thường sử dụng để check header domain và download file =))))\nSyntax: curl [OPTIONS] [URL]\nCác [OPTION] hay sử dụng:\n-O [URL] -O [URL]...: Tải về và giữ nguyên tên file (áp dụng cho nhiều files) -o [FILENAME] [URL] -o [FILENAME] [URL]...: Tải về và đổi tên file (cũng áp dụng cho nhiều files) -I: Lấy header content -X [METHOD]: Sử dụng phương thức HTTP cụ thể (GET, POST, PUT, DELETE, etc.) -d \u0026quot;param1=value1\u0026amp;param2=value2\u0026quot;: Gửi dữ liệu dạng param -H \u0026quot;HEADER: VALUE\u0026quot; (vd: -H \u0026quot;Content-Type: application/json\u0026quot;): Thêm header Ví dụ tải về adminer ver 4.8.1 với filename = adm.php: curl -o adm.php https://github.com/vrana/adminer/releases/download/v4.8.1/adminer-4.8.1-mysql-en.php\nCommand zip Nén file/folder vào 1 file nén dạng .zip Syntax: zip [OPTIONS] [ZIPFILE] [FILES/FOLDER] Các [OPTION] hay sử dụng: -r: Nén đệ quy tất cả các tệp và thư mục con -q: Không hiển thị thông tin trong quá trình nén -x [FILE/FOLDER] [FILE/FOLDER]...: Nén tất cả ngoại trừ các file/folder Với folder thì cần bổ xung **\\*, ví dụ: code/**\\*\n-e: Đặt mật khẩu -1 tới -9: Nén nhanh nhất cho tới nhẹ nhất Ví dụ clone code site khách: zip -rqe clone_27_05.zip * -x pub/media/catalog/**\\* pub/static/frontend/**\\* var/**\\* generated/code/**\\* Command trên chưa nén các file/folder dạng .filename như .git/ .gitignore .htaccess nên tuỳ nhu cầu sẽ bổ xung vào ngay trước option -x\nCommand unzip Giải nén file dạng .zip Syntax: unzip [OPTIONS] [ZIPFILE] Các [OPTION] hay sử dụng: -d [FOLDER]: Chỉ định thư mục đích -o: Ghi đè các tệp hiện có mà không cần hỏi -q: Không hiển thị thông tin trong quá trình giải nén -l: Liệt kê nội dung của tệp ZIP mà không giải nén Sau khi download file clone (có thể sử dụng cả scp hoặc curl), giải nén: unzip -oq clone_27_05.zip -d /var/www/html/v522-dev Command tar Được sử dụng để lưu trữ nhiều tệp và thư mục vào một tệp lưu trữ duy nhất (file.tar). Kết hợp với gzip/bzip2 để nén file đó thành dạng file.tar.gz hoặc file.tar.bz2 (tương tự zip) Syntax: tar [OPTIONS] [ARCHIVE] [FILES] Các [OPTION] hay sử dụng: -c: Tạo tệp mới -v: Hiển thị thông tin chi tiết trong quá trình thực thi -z: Nén bằng gzip -j: Nén bằng bzip2 -f: Chỉ định tên tệp lưu trữ -x: Giải nén tệp lưu trữ -t: Liệt kê nội dung của tệp lưu trữ mà không giải nén -C [PATH]: Chuyển đến thư mục trước khi giải nén Command ssh Được sử dụng để kết nối với một máy tính từ xa và thực thi các lệnh trên đó Syntax: ssh [OPTIONS] [USER]@[HOST] trong đó [USER] là tên người dùng để login [HOST] là máy chủ login Các [OPTION] hay sử dụng: -p [PORT]: Chỉ định cổng kết nối (mặc định [PORT] = 22) -i [KEYFILE]: Chỉ định tệp khoá (dạng key, key.pem,\u0026hellip;) Command scp Được sử dụng để sao chép tệp tin và thư mục giữa các máy tính qua kết nối SSH Syntax: scp [OPTIONS] [USER]@[HOST]:[SRC] [USER]@[HOST]:DEST Các [OPTION] hay sử dụng: -P [port]: Chỉ định cổng kết nối SSH -i [KEYFILE]: Chỉ định tệp khoá (dạng key, key.pem,\u0026hellip;) -r: Sao chép đệ quy toàn bộ thư mục và các tệp con -v: Hiển thị thông tin chi tiết trong quá trình sao chép Để upload từ file ở session ssh hiện tại (hoặc local) thì không cần cặp [USER]@[HOST] thứ 1 (download thì cặp thứ 2). Chỉ cần đường dẫn tới file/folder đó.\nCommand ssh-keygen Được sử dụng để tạo, quản lý và chuyển đổi key Syntax: ssh-keygen [OPTIONS] Các [OPTION] hay sử dụng: -t [TYPE]: Xác định loại thuật toán để tạo khóa (các [TYPE] phổ biển: RSA, DSA, ECDSA, và ED25519) -b [BIT]: Xác định độ dài của khóa (tính bằng bit) (thông thường là 2048 hoặc 4096 cho RSA) -C [COMMENT]: thêm comment vào khoá, thường là thông tin nhận dạng như email. -f [FILE]: xác định tên file và đường dẫn lưu key -N [PASSPHRASE]: thiết lập passpharse, dể rỗng nếu không muốn sử dụng. Command ssh-copy-id Dùng để sao chép public key vào remote server, giúp thiết lập xác thực không mật khẩu với SSH. Syntax: ssh-copy-id [OPTIONS] [USER]@[HOST] Các [OPTION] hay sử dụng: -p [PORT]: Chỉ định cổng kết nối (mặc định [PORT] = 22) -i [KEYFILE]: Chỉ định tệp public key (mặc định [KEYFILE] = ~/.ssh/id_rsa) -f: Buộc sao chép key ngay cả khi key đã tồn tại Command service Được sử dụng để khởi động, dừng và quản lý các dịch vụ hệ thống Syntax: service [SERVICE_NAME] [COMMAND] trong đó: SERVICE_NAME là tên của dịch vụ. COMMAND là hành động cần thực hiện (start, stop, restart, status, \u0026hellip;). Các [COMMAND] hay sử dụng: start: Khởi động dịch vụ. stop: Dừng dịch vụ. restart: Khởi động lại dịch vụ, stop =\u0026gt; start. reload: Tải lại cấu hình của dịch vụ mà không khởi động lại. status: Kiểm tra trạng thái của dịch vụ. enable: Kích hoạt dịch vụ để tự động khởi động khi hệ thống khởi động. disable: Vô hiệu hóa dịch vụ để không tự động khởi động khi hệ thống khởi động. Command systemctl Một công cụ quản lý dịch vụ mạnh mẽ và linh hoạt hơn service, được sử dụng với systemd Syntax: systemctl [OPTIONS] [COMMAND] [SERVICE_NAME] Các [COMMAND] cơ bản tương tự như service và bổ xung: is-active: Kiểm tra xem dịch vụ có đang chạy không. is-enabled: Kiểm tra xem dịch vụ có được kích hoạt không. Command mysql Được sử dụng để kết nối và tương tác với máy chủ MySQL từ dòng lệnh (thường để check connection) Syntax: mysql [OPTIONS] Các [OPTION] hay sử dụng: -u USER: Chỉ định tên người dùng MySQL -p: Prompt nhập mật khẩu, có thể sử dụng -pPASSWORD nếu không muốn hiện prompt (không khuyến cáo vì lộ mật khẩu). -h HOST: Chỉ định máy chủ MySQL (mặc định là localhost). -P PORT: Chỉ định cổng kết nối MySQL (mặc định là 3306). -e \u0026quot;SQL_QUERY\u0026quot;: Thực thi câu lệnh SQL từ dòng lệnh. -v: mode debug, hiển thị tiến trình Command import, thêm option \u0026lt;: mysql -u user -p database \u0026lt; file_dump.sql Command mysqldump Được sử dụng để kết nối và tương tác với máy chủ MySQL phục vụ việc export databases/tables. Syntax: mysqldump [OPTIONS] [DB_NAME] [TABLES] Các [OPTION] hay sử dụng, tương tự như mysql nhưng bổ xung các [OPTIONS] phục vụ việc export như: --opt: Tối ưu hóa quá trình xuất dữ liệu (thường được bật sẵn mặc định) bằng cách kết hợp nhiều tùy chọn khác nhau gồm: --add-drop-table: Thêm câu lệnh DROP TABLE trước mỗi câu lệnh CREATE TABLE. --add-locks: Thêm các câu lệnh LOCK TABLES và UNLOCK TABLES trước và sau khi chèn dữ liệu. --create-options: Bao gồm tất cả các tùy chọn của bảng trong câu lệnh CREATE TABLE. --disable-keys: Tạm thời vô hiệu hóa các primary/foreign keys khi chèn dữ liệu. --extended-insert: Sử dụng câu lệnh INSERT mở rộng, giúp giảm kích thước tệp xuất. --quick: Đọc hàng từ bảng một cách nhanh chóng mà không lưu trữ toàn bộ bảng trong bộ nhớ. --lock-tables: Khóa tất cả các bảng để đảm bảo tính nhất quán trong bản sao lưu. --complete-insert: Tạo ra các câu lệnh INSERT với đầy đủ tên các cột, đảm bảo tính toàn vẹn khi nhập lại dữ liệu. --single-transaction: Đảm bảo tính nhất quán dữ liệu khi sao lưu (chỉ dành cho InnoDB). --verbose: Chế độ debug, hiển thị thêm thông tin về tiến trình import. --add-drop-database: Thêm câu lệnh DROP DATABASE trước khi tạo lại cơ sở dữ liệu (phù hợp với user có quyền CREATE DATABASE). --all-databases: Sao lưu tất cả các cơ sở dữ liệu. Để biết thêm về các options bổ xung, truy cập link sau.\nCommand redis-cli Được sử dụng để tương tác với máy chủ Redis từ dòng lệnh như quản lý cơ sở dữ liệu, kiểm tra trạng thái,\u0026hellip;\nSyntax: redis-cli [OPTION] [COMMAND] [ARGUMENT]\noptions: Các tùy chọn cấu hình kết nối. command: Lệnh Redis để thực thi. arguments: Các đối số của lệnh Redis. Các [OPTION] hay sử dụng:\n-h: Chỉ định host. -p: Chỉ định port. -a: Chỉ định mật khẩu. -n: Chỉ định cơ sở dữ liệu (default là 0). Các [COMMAND] hay sử dụng:\nping: Kiểm tra kết nối. INFO keyspace: Liệt kê các db. select [DBNAME]: chuyển đổi giữa các cơ sở dữ liệu. flushdb: xoá tất các keys trong db hiện tại (xoá cache redis). Các db là dạng số, nằm trong khoảng min = 0 mà max = config databases trong file /etc/redis.conf (default).\nCommand varnish varnishd là dịch vụ chính của Varnish, được sử dụng để khởi động và quản lý Varnish.\nSyntax: varnishd [OPTION]\n[OPTION] hay sử dụng có -f [FILENAME]: Chỉ định tệp cấu hình VCL (thường mình export trong backend và config lại host port về webserver - apache/nginx)\nvarnishlog dùng để debug varnish real-time.\nSyntax: varnishlog [OPTIONS]\nCác [OPTION] hay sử dụng cho varnishlog:\n-g [GROUP]: Chỉ định nhóm các log để hiển thị (request hoặc session). -o: Hiển thị log ở chế độ một dòng (one-line). -q query: Lọc các log bằng ngôn ngữ truy vấn VSL Ví dụ, hiển thị các log lỗi client 503: varnishlog -g request -q 'RespStatus == 503' -g request\nCommand docker Là 1 công cụ quản lý các containers Cho phép bạn đóng gói ứng dụng và các phụ thuộc của nó vào một đơn vị container, giúp đảm bảo rằng ứng dụng sẽ chạy nhất quán trên mọi môi trường (linux, window, macos,\u0026hellip;). Syntax: docker [COMMAND] [OPTION] Các [COMMAND] cùng [OPTION] đi kèm: docker pull [IMAGE]:[TAG]: Tải xuống một image từ Docker Hub (không điền tag thì mặc định sẽ lấy mới nhất). docker images: Liệt kê các image Docker đã tải xuống. -a: liệt kê các image bị ẩn. docker rmi [IMAGE_ID]: xoá image. docker volume [COMMAND]: quản lý các volume. ls: Liệt kê các volume. create [VOLUME_NAME]: Tạo một volume mới. rm [VOLUME_NAME] [VOLUME_NAME]...: xoá 1 hoặc nhiều volume docker network: Quản lý các network Docker. ls: Liệt kê các network. create [NETWORK_NAME]: Tạo một network mới. connect [NETWORK_NAME] [CONTAINER_NAME]: Kết nối một container vào một network. disconnect [NETWORK_NAME] [CONTAINER_NAME]: Ngắt kết nối một container khỏi một network. rm [NETWORK_NAME] [NETWORK_NAME]...: xoá 1 hoặc nhiều network Thường sử dụng bridge network.\ndocker run [OPTION] [IMAGE]:[TAG]: Chạy một container từ một image. -d: Chạy container ở chế độ nền -p [LOCAL_PORT]:[CONATINER_PORT]: Map cổng từ host tới container. --name [CONTAINER_NAME]: Đặt tên cho container. -e [VARIABLE]=[VALUE]: Thiết lập biến môi trường cho container. -v: Mount một volume vào container (volume có thể là folder). docker stop [CONTAINER_NAME]: Dừng một container đang chạy. docker start [CONTAINER_NAME]: Khởi chạy một container. docker restart [CONTAINER_NAME]: Khởi động lại một container. docker rm [CONTAINER_NAME]: Xóa một container. docker ps: list các container đang chạy -a: list thêm các container bị lỗi/đang stop docker logs [CONTAINER_NAME]: Xem log của một container. -f: Xem log real-time. docker exec: Chạy một lệnh trong một container đang chạy. -it: Chạy lệnh trong chế độ tương tác (login thẳng vào container đó) -u [USER]: login bằng user cụ thể. -w [PATH]: login vào đường dẫn cụ thể docker inspect [CONTAINER_NAME/IMAGE/VOLUME/NETWORK]: xem chi tiết thông tin của container/image/volume/network. Để biết thêm về các docker, truy cập thông tin bổ sung về Docker.\nCommand docker-compose Là 1 công cụ quản lý các container thông qua tệp YAML/YML. Syntax: docker-compose [COMMAND] [OPTION] docker-compose cũng có các [COMMAND] tương tự như docker như ps, stop/start/restart container, logs (-f), pull. Ngoài ra còn có: docker-compose up: Tạo và khởi động container. -d: Chạy ở chế độ nền. --build: Xây dựng lại image trước khi khởi động. docker-compose down: Dừng và xóa container. --volumes: Xóa các volume liên kết. docker-compose build: Build hoặc rebuild container. --no-cache: Không sử dụng các cache layers. docker-compose config: Kiểm tra cấu hình. "
},
{
	"uri": "/1-server/1.2-additional/1.2.1-permission/",
	"title": "Phân Quyền",
	"tags": [],
	"description": "",
	"content": "Theo quyền sở hữu (Ownership) Mỗi file/foler đều được gán 3 kiểu user:\nOwner: mặc định file/folder được tạo ra bởi user nào thì file/folder đó thuộc quyền sở hữu của user đó (để biết user hiện tại sử dụng command whoami hoặc kiểm tra đầu dòng của terminal) Group: tập hợp 1 nhóm user (kiểm tra user hiện tại có thuộc group không bằng cách sử dụng command groups) Other: tất cả những user còn lại Sử dụng command chown để chuyển quyền sở hữu sang user/group khác.\nTheo quyền thực thi (Permissions) Mỗi file/folder sẽ có 3 quyền thực thi dành cho từng kiểu user:\nRead: viết tắt là r và tượng trưng cho số 4, quyền đọc Nếu là file thì user sẽ đọc được nội dung Nếu là folder thì user sẽ xem được danh sách file/folder bên trong Write: viết tắt là w và tượng trưng cho số 2, quyền viết Nếu là file thì user sẽ chỉnh sửa file đó Nếu là folder thì user có thể thêm, xóa và đổi tên các file/folder trong thư mục đó. Execute: viết tắt là x và tượng trưng cho số 1, quyền chạy file (tương tự file .exe trên Windows) Nếu là file thì user có thể khởi chạy file Nếu là folder thì user có thể truy cập folder đó (command cd) Sử dụng command chmod để thay đổi quyền thực thi.\nThực hành Để xem quyền, thường sử dụng command ls -l\nTheo như ảnh trên:\nFolder app:\nOwner (sshuser) có full quyền: read, write, execute | rwx | 4 + 2 +1 =7 Group (www-data) và Other đề có 2 quyền read, execute | r-x | 4 + 0 + 1 = 5 ==\u0026gt; folder app có có quyền thực thi là 755 File auth.json:\nOwner (sshuser) có 1 quyền: read | r-- | 4 + 0 + 0 = 4 Group (www-data) và Other không có quyền | --- | 0 + 0 + 0 = 0 ==\u0026gt; file auth.json có có quyền thực thi là 400 File auth.json.sample:\nOwner (sshuser) có 2 quyền: read, write | rw- | 4 + 2 + 0 = 6 Group (www-data) và Other có 1 quyền read | r-- | 4 + 0 + 0 = 4 ==\u0026gt; file auth.json.sample có có quyền thực thi là 644 Ngoài dạng số (r-4, w-2, x-1) chúng ta cũng có thể sử dụng dạng chữ để phân quyền thực thi qua chmod:\nTên file/folder Quyền thực thi Câu lệnh sử dụng dạng số Câu lệnh sử dụng dạng chữ app rwxr-xr-x chmod 755 chmod u+rwx g+rx o+rx auth.json r\u0026mdash;\u0026mdash;\u0026ndash; chmod 400 chmod u+r auth.json.sample rw-r\u0026ndash;r\u0026ndash; chmod 644 chmod u+rw g+r o+r Trong đó:\nKí tự Ý nghĩa u user g group o other "
},
{
	"uri": "/",
	"title": "RDS WIKI",
	"tags": [],
	"description": "",
	"content": "Trang chủ 1. Kiến thức Server 2. Hệ thống "
},
{
	"uri": "/1-server/",
	"title": "Server",
	"tags": [],
	"description": "",
	"content": "1. Các lệnh cơ bản 2. Bổ xung "
},
{
	"uri": "/1-server/1.3-services/1.3.1-varnish/",
	"title": "Varnish",
	"tags": [],
	"description": "",
	"content": "1. Tổng quan Là 1 middleware giữa webserver (backend) và browser (frontend), đảm nhận trách nhiệm lưu trữ các bản cache ngoài frontend (static content, api response, fpc,\u0026hellip;) Giúp người dùng truy xuất nhanh hơn (rất nhanh luôn =))) nội dung ngoài trình duyệt và giảm tải cho backend Phù hợp với các website nhiều nội dung và được truy cập thường xuyên như blog, privacy, news\u0026hellip; Chúng ta có thể tuỳ biến để Varnish để lưu và truy xuất cache thông qua file VCL (Varnish Configuration Language) Cấu trúc: file default.vcl (/etc/varnish/default.vcl) file cấu hình của varnish file secret (/etc/varnish/secret) được dùng để xác thực các yêu cầu quản trị như command varnishadm, varnishd (tương tự file key) 2. Sử dụng Varnish trong Magento 2 Trong Magento 2, Varnish hoạt động dưới dạng fpc (full page cache) thay thế cho built-in cache Các page varnish lưu trữ cache (default): product page, catalog page, cms page, search page, privacy page. 3. Các lệnh cơ bản Bên cạnh varnishd và varnishlog tại page các câu lệnh varnish cơ bản thì còn bổ xung thêm vài command để quản trị như sau:\nvarnishadm: dùng để truy cập khu vực admin của varnish (yêu cầu root user)\nSyntax: varnishadm -S [SECRET_FILE] -T [HOST]:[PORT] Xem thêm tại đây varnishstat: hiển thị các con số thống kê chi tiết trong quá trình xử lý cache của Varnish (số lượng page cache, tỉ lệ hit/miss, số lần đẩy request xuống backend ,\u0026hellip;)\nSyntax: varnishstat [OPTIONS] (thường các option được sử dụng để làm báo cáo, xem thêm tại đây) varnishhist: đối chiếu giữa các lượt request đến cache (HIT) so với các lượt request trực tiếp vào backend\nSyntax: varnishhist [OPTIONS] (thường các option được sử dụng để làm báo cáo, xem thêm tại đây) 4. File vcl Không lưu trữ cache các thông tin động và nhạy cảm như dữ liệu thanh toán (payment), giỏ hàng (cart), đăng nhập (login),\u0026hellip;\na. Sơ lược Được cấu trúc bởi các chương trình con (subroutines - gọi tắt là sub, tương tự như 1 function)\nMỗi sub sẽ đều có 1 chức năng khi các đoạn code bên trong mỗi sub khớp với chỉ thị của các truy cập gửi vào server (mỗi sub chỉ được khai báo 1 lần =\u0026gt; không được trùng lặp)\nMặc định nếu file default.vcl không có nội dung VCL nào ngoài dòng backend server để khai báo cổng kết nối của backend, thì tất cả các page đều được gắn cache và tự động hủy (purge) sau 2 phút.\nNgoài ra còn có 2 thành phần quan trọng khác là:\nbackend: cấu hình webserver/backend nhận request acl: cơ chế để kiểm soát quyền truy cập, cho phép sử dụng dns/ip/dải ip. b. Cú pháp sub sub_name {\r// rules\r} Cú pháp sub: Định dạng chuỗi: luôn đặt trong dấu nháy đôi, ví dụ: req.url ~ \u0026quot;(?i)\\.(png|gif|jpeg|jpg|ico|swf|css|js|html|htm)(\\?[a-z0-9]+)?$\u0026quot; ) Toán tử: Gán giá trị: = So sánh tuyệt đối: == So sánh tương đối hoặc sử dụng regex: ~ Phủ định: ! Toán tử và: \u0026amp;\u0026amp; Toán tử hoặc: || c. Các biến toàn cục (global variables) Các biến toàn cục có thể được gán giá trị bằng từ khóa set hoặc unset để bỏ gán\nThông số Giải thích now thời gian hiện tại client.ip ip của người dùng qua browser server.hostname tên máy chủ server.ip địa chỉ ip máy chủ server.port Cổng máy chủ được truy cập req request res response beresp backend response req.backend tên backend xử lý request req.backend.healthy tình trạng backend req.hash_always_miss buộc một yêu cầu cụ thể luôn bỏ qua bộ nhớ cache req.http.header thông tin header địa chỉ request req.method thông tin phương thức được sử dụng qua request req.proto phương thức được request req.restarts số lần 1 request được xử lý lại req.request các loại request (POST, GET,\u0026hellip;) req.url url được request d. Các sub có sẵn Các ví dụ bên dưới đều sử dụng qua file varnish 6 default export của magento 2\nvcl_recv (revceive):\nĐặc điểm: được gọi ra khi bắt đầu khách gửi 1 request, điều hướng request người dùng tới data cache hoặc thẳng vào backend. Tiến trình xử lý: return (hash): điều hướng tới cache bằng cách gán cho request đó 1 mã băm riêng biệt (Varnish sẽ chuyển đến sub vcl_hash). return (pass): Varnish sẽ gửi truy vấn đến trực tiếp backend mà không có cache. return (pipe): chuyển request đến Pipe Mode dựa trên sub vcl_pipe. return (purge): chuyển request thành 1 request không phù hợp để loại bỏ (được xử lý thông qua sub vcl_hash và vcl_purge). Ví dụ\rsub vcl_recv {\rif (req.restarts \u0026gt; 0) {\rset req.hash_always_miss = true;\r}\rif (req.method == \u0026#34;PURGE\u0026#34;) {\rif (client.ip !~ purge) {\rreturn (synth(405, \u0026#34;Method not allowed\u0026#34;));\r}\r# To use the X-Pool header for purging varnish during automated deployments, make sure the X-Pool header\r# has been added to the response in your backend server config. This is used, for example, by the\r# capistrano-magento2 gem for purging old content from varnish during it\u0026#39;s deploy routine.\rif (!req.http.X-Magento-Tags-Pattern \u0026amp;\u0026amp; !req.http.X-Pool) {\rreturn (synth(400, \u0026#34;X-Magento-Tags-Pattern or X-Pool header required\u0026#34;));\r}\rif (req.http.X-Magento-Tags-Pattern) {\rban(\u0026#34;obj.http.X-Magento-Tags ~ \u0026#34; + req.http.X-Magento-Tags-Pattern);\r}\rif (req.http.X-Pool) {\rban(\u0026#34;obj.http.X-Pool ~ \u0026#34; + req.http.X-Pool);\r}\rreturn (synth(200, \u0026#34;Purged\u0026#34;));\r}\rif (req.method != \u0026#34;GET\u0026#34; \u0026amp;\u0026amp;\rreq.method != \u0026#34;HEAD\u0026#34; \u0026amp;\u0026amp;\rreq.method != \u0026#34;PUT\u0026#34; \u0026amp;\u0026amp;\rreq.method != \u0026#34;POST\u0026#34; \u0026amp;\u0026amp;\rreq.method != \u0026#34;TRACE\u0026#34; \u0026amp;\u0026amp;\rreq.method != \u0026#34;OPTIONS\u0026#34; \u0026amp;\u0026amp;\rreq.method != \u0026#34;DELETE\u0026#34;) {\r/* Non-RFC2616 or CONNECT which is weird. */\rreturn (pipe);\r}\r# We only deal with GET and HEAD by default\rif (req.method != \u0026#34;GET\u0026#34; \u0026amp;\u0026amp; req.method != \u0026#34;HEAD\u0026#34;) {\rreturn (pass);\r}\r# Bypass customer, shopping cart, checkout\rif (req.url ~ \u0026#34;/customer\u0026#34; || req.url ~ \u0026#34;/checkout\u0026#34;) {\rreturn (pass);\r}\r# Bypass health check requests\rif (req.url ~ \u0026#34;^/(pub/)?(health_check.php)$\u0026#34;) {\rreturn (pass);\r}\r# Set initial grace period usage status\rset req.http.grace = \u0026#34;none\u0026#34;;\r# normalize url in case of leading HTTP scheme and domain\rset req.url = regsub(req.url, \u0026#34;^http[s]?://\u0026#34;, \u0026#34;\u0026#34;);\r# collect all cookies\rstd.collect(req.http.Cookie);\r# Compression filter. See https://www.varnish-cache.org/trac/wiki/FAQ/Compression\rif (req.http.Accept-Encoding) {\rif (req.url ~ \u0026#34;\\.(jpg|jpeg|png|gif|gz|tgz|bz2|tbz|mp3|ogg|swf|flv)$\u0026#34;) {\r# No point in compressing these\runset req.http.Accept-Encoding;\r} elsif (req.http.Accept-Encoding ~ \u0026#34;gzip\u0026#34;) {\rset req.http.Accept-Encoding = \u0026#34;gzip\u0026#34;;\r} elsif (req.http.Accept-Encoding ~ \u0026#34;deflate\u0026#34; \u0026amp;\u0026amp; req.http.user-agent !~ \u0026#34;MSIE\u0026#34;) {\rset req.http.Accept-Encoding = \u0026#34;deflate\u0026#34;;\r} else {\r# unknown algorithm\runset req.http.Accept-Encoding;\r}\r}\r# Remove all marketing get parameters to minimize the cache objects\rif (req.url ~ \u0026#34;(\\?|\u0026amp;)(gclid|cx|ie|cof|siteurl|zanpid|origin|fbclid|mc_[a-z]+|utm_[a-z]+|_bta_[a-z]+)=\u0026#34;) {\rset req.url = regsuball(req.url, \u0026#34;(gclid|cx|ie|cof|siteurl|zanpid|origin|fbclid|mc_[a-z]+|utm_[a-z]+|_bta_[a-z]+)=[-_A-z0-9+()%.]+\u0026amp;?\u0026#34;, \u0026#34;\u0026#34;);\rset req.url = regsub(req.url, \u0026#34;[?|\u0026amp;]+$\u0026#34;, \u0026#34;\u0026#34;);\r}\r# Static files caching\rif (req.url ~ \u0026#34;^/(pub/)?(media|static)/\u0026#34;) {\r# Static files should not be cached by default\rreturn (pass);\r# But if you use a few locales and don\u0026#39;t use CDN you can enable caching static files by commenting previous line (#return (pass);) and uncommenting next 3 lines\r#unset req.http.Https;\r#unset req.http.X-Forwarded-Proto;\r#unset req.http.Cookie;\r}\r# Bypass authenticated GraphQL requests without a X-Magento-Cache-Id\rif (req.url ~ \u0026#34;/graphql\u0026#34; \u0026amp;\u0026amp; !req.http.X-Magento-Cache-Id \u0026amp;\u0026amp; req.http.Authorization ~ \u0026#34;^Bearer\u0026#34;) {\rreturn (pass);\r}\rreturn (hash);\r} vcl_pipe:\nĐặc điểm: mở một kết nối hai chiều TCP Proxy để request có thể gửi thẳng đến backend và ngược lại (thường dành cho streaming, tạo 1 connect thẳng tới backend). Note: không có sub nào được xử lý sau khi Pipe Mode kết thúc vcl_pass:\nĐặc điểm: gửi request thẳng tới backend và backend trả lại dữ liệu không thông qua cache (Pass mode) Tiến trình: kết thúc với 1 trong 2 return sau: return (fetch): báo hiệu request vào Pass mode và backend bắt đầu xử lý. return (restart): bắt đầu lại quá trình chuyển request. vcl_hit:\nĐặc điểm: được gọi ra khi Varnish tìm thấy 1 bản cache phù hợp Tiến trình: kết thúc bằng 1 trong các return sau return (deliver): trả response được cache cho người dùng. return (fetch): Đồng bộ lại dữ liệu của đối tượng đã được lưu cache với nội dung trả về từ backend server (sub vcl_miss sẽ bắt đầu làm việc). return (pass): Gửi request vào Pass mode với ``vcl_pass. return (restart): bắt đầu lại quá trình chuyển request. Ví dụ\rsub vcl_hit {\rif (obj.ttl \u0026gt;= 0s) {\r# Hit within TTL period\rreturn (deliver);\r}\rif (std.healthy(req.backend_hint)) {\rif (obj.ttl + s \u0026gt; 0s) {\r# Hit after TTL expiration, but within grace period\rset req.http.grace = \u0026#34;normal (healthy server)\u0026#34;;\rreturn (deliver);\r} else {\r# Hit after TTL and grace expiration\rreturn (restart);\r}\r} else {\r# server is not healthy, retrieve from cache\rset req.http.grace = \u0026#34;unlimited (unhealthy server)\u0026#34;;\rreturn (deliver);\r}\r} vcl_miss:\nĐặc điểm: chuyển request qua backend, được kích hoạt nếu request không tìm thấy đối tượng cache phù hợp, hoặc request được return(fetch) ở sub vcl_hit Tiến trình: kết thúc bằng 1 trong các return sau return (fetch): nhận data được request đến backend thông qua sub vcl_backend_fetch. return (pass): Đưa request vào Pass mode và xử lý bằng vcl_pass. return (restart): bắt đầu lại quá trình chuyển request. vcl_backend_fetch:\nĐặc điểm: kiểm soát hành vi của Varnish trước khi gửi yêu cầu đến backend Tiến trình: return (fetch) gửi yêu cầu đến backend sau khi tất cả các thao tác điều chỉnh đã hoàn tất. vcl_backend_response:\nĐặc điểm: được sử dụng để xử lý phản hồi từ backend trước khi nó được lưu trữ vào cache hoặc gửi tới client Tiến trình: return (pass): đưa request vào Pass mode và xử lý bằng vcl_pass. return (deliver): trả response được cache cho người dùng. Ví dụ\rsub vcl_backend_response {\rset beresp.grace = 3d;\rif (beresp.http.content-type ~ \u0026#34;text\u0026#34;) {\rset beresp.do_esi = true;\r}\rif (bereq.url ~ \u0026#34;\\.js$\u0026#34; || beresp.http.content-type ~ \u0026#34;text\u0026#34;) {\rset beresp.do_gzip = true;\r}\rif (beresp.http.X-Magento-Debug) {\rset beresp.http.X-Magento-Cache-Control = beresp.http.Cache-Control;\r}\r# cache only successfully responses and 404s that are not marked as private\rif (beresp.status != 200 \u0026amp;\u0026amp;\rberesp.status != 404 \u0026amp;\u0026amp;\rberesp.http.Cache-Control ~ \u0026#34;private\u0026#34;) {\rset beresp.uncacheable = true;\rset beresp.ttl = 86400s;\rreturn (deliver);\r}\r# validate if we need to cache it and prevent from setting cookie\rif (beresp.ttl \u0026gt; 0s \u0026amp;\u0026amp; (bereq.method == \u0026#34;GET\u0026#34; || bereq.method == \u0026#34;HEAD\u0026#34;)) {\runset beresp.http.set-cookie;\r}\r# If page is not cacheable then bypass varnish for 2 minutes as Hit-For-Pass\rif (beresp.ttl \u0026lt;= 0s ||\rberesp.http.Surrogate-control ~ \u0026#34;no-store\u0026#34; ||\r(!beresp.http.Surrogate-Control \u0026amp;\u0026amp;\rberesp.http.Cache-Control ~ \u0026#34;no-cache|no-store\u0026#34;) ||\rberesp.http.Vary == \u0026#34;*\u0026#34;) {\r# Mark as Hit-For-Pass for the next 2 minutes\rset beresp.ttl = 120s;\rset beresp.uncacheable = true;\r}\r# If the cache key in the Magento response doesn\u0026#39;t match the one that was sent in the request, don\u0026#39;t cache under the request\u0026#39;s key\rif (bereq.url ~ \u0026#34;/graphql\u0026#34; \u0026amp;\u0026amp; bereq.http.X-Magento-Cache-Id \u0026amp;\u0026amp; bereq.http.X-Magento-Cache-Id != beresp.http.X-Magento-Cache-Id) {\rset beresp.ttl = 0s;\rset beresp.uncacheable = true;\r}\rreturn (deliver);\r} vcl_hash:\nĐặc điểm: được sử dụng như để tìm ra một đối tượng đã được cache trong Varnish bằng một mã băm Tiến trình: return(lookup) để tìm một đối tượng cache Ví dụ\rsub vcl_hash {\rif ((req.url !~ \u0026#34;/graphql\u0026#34; || !req.http.X-Magento-Cache-Id) \u0026amp;\u0026amp; req.http.cookie ~ \u0026#34;X-Magento-Vary=\u0026#34;) {\rhash_data(regsub(req.http.cookie, \u0026#34;^.*?X-Magento-Vary=([^;]+);*.*$\u0026#34;, \u0026#34;\\1\u0026#34;));\r}\r# To make sure http users don\u0026#39;t see ssl warning\rif (req.http.X-Forwarded-Proto) {\rhash_data(req.http.X-Forwarded-Proto);\r}\rif (req.url ~ \u0026#34;/graphql\u0026#34;) {\rcall process_graphql_headers;\r}\r} vcl_deliver:\nĐặc điểm: được gọi ra ngay trước khi cache được return cho người dùng (trừ kết quả của sub vcl_synth) Tiến trình: kết thúc bằng 1 trong các return sau return (deliver): trả response được cache cho người dùng. return (restart): bắt đầu lại quá trình chuyển request. Ví dụ\rsub vcl_deliver {\rif (resp.http.x-varnish ~ \u0026#34; \u0026#34;) {\rset resp.http.X-Magento-Cache-Debug = \u0026#34;HIT\u0026#34;;\rset resp.http.Grace = req.http.grace;\r} else {\rset resp.http.X-Magento-Cache-Debug = \u0026#34;MISS\u0026#34;;\r}\r# Not letting browser to cache non-static files.\rif (resp.http.Cache-Control !~ \u0026#34;private\u0026#34; \u0026amp;\u0026amp; req.url !~ \u0026#34;^/(pub/)?(media|static)/\u0026#34;) {\rset resp.http.Pragma = \u0026#34;no-cache\u0026#34;;\rset resp.http.Expires = \u0026#34;-1\u0026#34;;\rset resp.http.Cache-Control = \u0026#34;no-store, no-cache, must-revalidate, max-age=0\u0026#34;;\r}\rif (!resp.http.X-Magento-Debug) {\runset resp.http.Age;\r}\runset resp.http.X-Magento-Debug;\runset resp.http.X-Magento-Tags;\runset resp.http.X-Powered-By;\runset resp.http.Server;\runset resp.http.X-Varnish;\runset resp.http.Via;\runset resp.http.Link;\r} vcl_purge:\nĐặc điểm: được gọi ra khi quá trình purge bắt đầu Tiến trình: return (restart) để bắt đầu lại quá trình chuyển request. vcl_error: được thực thi khi webserver bị lỗi không truy cập được để lấy dữ liệu\n"
},
{
	"uri": "/2-system/2.1-xteam/",
	"title": "XTEAM",
	"tags": [],
	"description": "",
	"content": "Tổng quan Là hệ thống quản lý các devsites, demosites trong đó team RDS sử dụng bao gồm auto devsite sử dụng nhà cung cấp AWS và demosite sử dụng Linode Hướng dẫn sử dụng "
},
{
	"uri": "/1-server/1.2-additional/",
	"title": "Bổ xung",
	"tags": [],
	"description": "",
	"content": "1. Phân Quyền 2. Magento Cloud 2. Ssh key "
},
{
	"uri": "/1-server/1.3-services/1.3.2-fastly-cdn/",
	"title": "Fastly CDN",
	"tags": [],
	"description": "",
	"content": "1. Tổng quan Là một dịch vụ mạng phân phối nội dung (Content Delivery Network - CDN) và cung cấp các giải pháp về bảo mật và hiệu suất cho các ứng dụng web. Các dịch vụ mà Fastly cung cấp bên cạnh CDN: Bảo mật (Security): WAF, chống DDoS và bảo mật TLS/SSL Tối ưu (Optimization): load speed, network optimization Điện toán đám mây (Compute): khả năng mở rộng cao, ứng dụng phân tán quy mô toàn cầu Giám sát (Observability): phân tích thời gian thực, giám sát và cảnh báo Trong bài này chúng ta sẽ chủ yếu làm việc với dịch vụ CDN 2. Tạo CDN service 3. Ứng dụng trong magento 2 3.1: Cần cài module Fastly_Cdn\nBước 1: download source code composer require fastly/magento2 Bước 2: install module php bin/magento module:enable Fastly_Cdn\rphp bin/magento setup:upgrade\rphp bin/magento setup:static-content:deploy Bước 3: kiểm tra trạng thái module php bin/magento module:status Bước 4: truy cập và setup config trong backend (Store =\u0026gt; Configuration =\u0026gt; Advanced =\u0026gt; System =\u0026gt; Full Page Cache) 3.2: Config\nOverview\rGet Service ID\rGet Token\rCách 1: truy cập list CDN Services Cách 2: truy cập trang view detail Sau khi test connection ok thì ta Upload VCL to Fastly, Save Config và Flush Cache để áp dụng config mới nhất\n3.3: Configure static content 4. Thông tin trang detail CDN Services 5. Thông tin configuration page Mỗi khi config trong backend magento thì cần click Upload VCL to Fastly thay vì Save Config 5.1: Config Domain\n5.2: Config Host/Backend\n5.3: Config Custom Snippests\n5.4: Config Custom VCL\nLà 1 config giúp mình trực tiếp chỉnh sửa và upload file vcl thay vì check từng config 5.5: Config Image Optimizer\nLà 1 giải pháp tối ưu hình ảnh tích hợp trong CDN Giúp: Tăng tốc độ tải trang: giảm kích thước và tự động điều chỉnh hình ảnh Tiết kiệm băng thông: giảm dung lượng hình ảnh Giảm chi phí hạ tầng: hình ảnh được tối ưu và cache trên CDN "
},
{
	"uri": "/2-system/",
	"title": "Hệ thống",
	"tags": [],
	"description": "",
	"content": "Các hệ thống hiện tại team R\u0026amp;D sử dụng Xteam UptimeRobot Monitor "
},
{
	"uri": "/1-server/1.2-additional/1.2.2-magento-cloud/",
	"title": "Magento Cloud",
	"tags": [],
	"description": "",
	"content": "Hướng dẫn connect ssh site khách sử dụng magento cloud cli Bước 1: Tạo api-key từ account adobe được thêm vào project của khách Step Description Truy cập account page Tạo key Lưu lại key Bước 2: Cài đặt magento cloud cli Cài đặt các thư viện php cần thiết (nếu server đã chạy magento sẵn thì bỏ qua bước này) (chỉ dành cho ubuntu, debian):\nsudo apt update sudo apt install software-properties-common sudo add-apt-repository ppa:ondrej/php sudo apt install php8.1-cli php8.1-{json,phar,openssl,pcre,curl,pcntl,posix} Tải xuống bản cài đặt của magento cloud cli: curl -sS https://accounts.magento.cloud/cli/installer | php Khai báo đường dẫn chạy command magento-cloud: export PATH=$PATH:$HOME/.magento-cloud/bin\nKiểm tra: magento-cloud --version Thêm api key đã tạo tại bước 1: magento-cloud auth:api-token-login Tham khảo trang chủ trên adobe để biết thêm chi tiết\nBước 3: Kết nối ssh Truy cập project page của khách và lấy command ssh: Dán vào màn hình console: Sau khi ssh thành công, mình chỉ có quyền write trong folder var.\nNgoài ssh chúng ta cũng có thể sử dụng các lệnh khách như lệnh git,\u0026hellip;\n"
},
{
	"uri": "/2-system/2.2-uptimerobot/",
	"title": "UPTIMEROBOT",
	"tags": [],
	"description": "",
	"content": "Tổng quan Là 1 công cụ giám sát độ ổn định của website, được thiết kế nhằm mục đích theo dõi và báo cáo về thời gian hoạt động của đường dẫn cụ thể Cách hoạt động: Đăng ký mục giám sát (create monitor) Kiểm tra định kỳ (kiểm tra trạng thái website sau 1 khoảng thời gian) Gửi yêu cầu kiểm tra Xử lý kết quả Thông báo lỗi Lưu trữ lịch sử giám sát Hướng dẫn sử dụng "
},
{
	"uri": "/1-server/1.3-services/",
	"title": "Các services",
	"tags": [],
	"description": "",
	"content": "Sơ lược Là những tiến trình (process) cơ bản (hoặc một Unit) hoạt động khi hệ điều hành khởi động, được quản lý bởi hệ thống Systemd, và luôn ở chế độ chạy ngầm hoặc chạy nền (background) Các Services thường được cấu hình trong các file riêng biệt và quản lý thông qua câu lệnh systemctl (các bản cũ là service) Sử dụng user root hoặc sudo để có thể sử dụng đầy đủ các action bên dưới\nNên kiểm tra các thay đổi trong các config file trước khi restart bất kì service nào xem thêm tại đây\nCác câu lệnh thường sử dụng: Systemctl\rService\rList các services: systemctl list-units --type=service Kiểm tra trạng thái (status): systemctl reload \u0026lt;service-name\u0026gt;\nChạy (start): systemctl start \u0026lt;service-name\u0026gt; Khởi động lại (restart) (kill tất cả process hiện tại): systemctl restart \u0026lt;service-name\u0026gt;\nTải lại (reload) (chỉ load lại các thay đổi): systemctl reload \u0026lt;service-name\u0026gt; Khởi động cùng hệ thống (enable) (cùng lúc server reboot/restart): systemctl reload \u0026lt;service-name\u0026gt;\nTắt khởi động cùng hệ thống (disable): systemctl reload \u0026lt;service-name\u0026gt;\nCheck log: journalctl -u service-name.service List các services: service --status-all Kiểm tra trạng thái (status): service \u0026lt;service-name\u0026gt; status Chạy (start): service \u0026lt;service-name\u0026gt; start\nKhởi động lại (restart) (kill tất cả process hiện tại): service \u0026lt;service-name\u0026gt; restart\nTải lại (reload) (chỉ load lại các thay đổi): systemctl \u0026lt;service-name\u0026gt; reload\nCheck log: journalctl -u service-name.service Kiểm tra config Nginx\rApache2\rPhp-fpm\rMysql\rsudo nginx -t\nsudo apachectl configtest\nThay thế 8.1 bằng version mình cần kiểm tra\nsudo php-fpm8.1 -t\n123333\nContent Varnish Fastly CDN "
},
{
	"uri": "/2-system/2.3-monitor/",
	"title": "MONITOR",
	"tags": [],
	"description": "",
	"content": "Tổng quan Hiện tại hệ thống demosite đang sử dụng Grafana và Prometheus để monitor server kết hợp các exporter như node_exporter, elasticsearch_exporter và mysql_exporter. Có thể tham khảo thêm các exporter tại đây.\nNgoài ra còn kết hợp Grafana cùng với Loki và Promtail để thu thập log file.\nCách Grafana hoạt động:\nTạo ra các dashboard linh hoạt, giúp hiển thị dữ liệu từ nhiều nguồn khác nhau dưới dạng biểu đồ, bảng, và nhiều loại widget khác. Tích hợp với nhiều nguồn dữ liệu (data source) phổ biến như Prometheus và Loki. Cung cấp tính năng cảnh báo, giúp theo dõi các giá trị quan trọng và gửi thông báo khi có sự cố hoặc khi các giá trị vượt ngưỡng. Cách Prometheus hoạt động:\nThu thập và lưu trữ các thông số dưới database của Prometheus (time serie database) Thu thập dữ liệu bằng cách kéo dữ liệu từ các exporter (targets, bản thân prometheus cũng chính là 1 exporter) mà nó cần giám sát về thông qua HTTP endpoint (target sẽ cung cấp 1 endpoint cụ thể dạng host:port/uri) (vd: localhost:9090/metrics) Prometheus cũng cung cấp cho chúng ta 1 giao diện UI thông qua địa chỉ máy ảo mà cài đặt nó với port 9090 (vd: localhost:9090/graph) Thông qua giao diện chúng ta có thể sử dụng truy vấn PromQL, vd: up{job=\u0026quot;prometheus\u0026quot;} Cách các exporter hoạt động:\nChạy như một dịch vụ (daemon) trên máy chủ Thu thập các dữ liệu theo từng kiểu exporter (mysql, server, \u0026hellip;) Cung cấp một HTTP endpoint (dạng host:port/uri , vd: localhost:9114/metrics) cho phép Prometheus truy vấn định kỳ (theo cấu hình scraping interval) để thu thập các số liệu. Loại exporter Mẫu dashboard dựng sẵn Link dashboard node_exporter link mysql_exporter link elasticsearch_exporter link promtail Quản lý tất cả access/error log của tất cả demosite - link "
},
{
	"uri": "/1-server/1.2-additional/1.2.3-sshkey/",
	"title": "SSH Key",
	"tags": [],
	"description": "",
	"content": "Tổng quan SSH keypair là một phương pháp bảo mật phổ biến để xác thực người dùng trên các hệ thống từ xa. 1 cặp key bao gồm: Public Key (Khóa công khai): Được lưu trên máy chủ đích. Máy chủ sử dụng khóa này để xác thực người dùng. (tương tự ổ khoá) Private Key (Khóa riêng tư): Được lưu trữ trên máy của người dùng. Người dùng sử dụng khóa này để chứng minh danh tính của mình với máy chủ. (tương tự chìa khoá) Hướng dẫn sử dụng 1. Sử dụng ssh-keygen để tạo ra cặp khoá: ssh-keygen -t rsa -b 4096 2. Lưu lại private key và in nội dung file public vào file ~/.ssh/authorized_keys trên remote server sử dụng ssh-copy-id: ssh-copy-id -i git_key -p port user@host Thay vì sử dụng ssh-copy-id, ta có thể copy nội dung file public_key.pub và dán nội dung vào file ~/.ssh/authorized_keys\nPublic key có thể sử dụng cho nhiều user trên cùng 1 server\nSử dụng file ssh config Giới thiệu: là một công cụ cho phép bạn cấu hình và tùy chỉnh các kết nối SSH với path là ~/.ssh/config Cấu trúc: Host host_name_alias HostName host_name User user_name Port port_connec IdentityFile path_key Trong đó\nHost: Xác định tên alias remote server, có thể sử dụng dấu * như một ký tự đại diện. vd: *.example.com HostName: địa chỉ ip hoặc domain của remote server User: tên người dùng để kết nối (optional) Port: cổng SSH để kết nối (mặc định là 22) (optional). IdentityFile: Đường dẫn đến private key (optional). 1 số ví dụ về kết nối:\nX-gitlab\rAuto devsite\rHost gitlab.bsscommerce.com IdentityFile /path/to/key Cần thêm public key của bạn lên x-gitlab trước rồi mới có thể sử dụng private key (các hệ thống khác như github, gitlab, bitbucket,\u0026hellip; tương tự)\nHost bsscommerce.com User ubuntu "
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]